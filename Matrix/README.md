Matrix [С++ fall 2022]

Ограничение времени	30 секунд
Ограничение памяти	64Mb
Ввод	стандартный ввод или input.txt
Вывод	стандартный вывод или output.txt
Цель этой задачи - 1) научиться пользоваться шаблонами, в частности, шаблонами с числовыми аргументами, и производить простейшие вычисления с помощью шаблонной рекурсии; 2) приобрести опыт переиспользования своего ООП-кода, написанного ранее (класс Rational); 3) повторить и закрепить для себя некоторые темы линейной и общей алгебры, полезные для общего развития. А также создать удобный фреймворк для себя самого, который может помочь в будущем решать некоторые задачи из алгебры :)

Баллы за эту задачу можно получить только при условии прохождения тестов по задачам BigInteger и Rational.

Написать шаблонный класс Residue<size_t N>, реализующий концепцию конечного поля из N элементов. Должны поддерживаться арифметические операции, кроме деления, а в случае простого N и деление тоже. Элемент поля Residue<N> должно быть можно сконструировать от int путем взятия остатка от деления на N (в математическом смысле). Также должно быть можно привести Residue<N> к int (но преобразования должны быть явными в обе стороны, разумеется).

Замечание: попытка вызвать операцию деления при составном N должна приводить к ошибке компиляции, а не времени выполнения. Для знатоков: слово constexpr, а также нововведения C++20 для compile-time вычислений в этой задаче использовать запрещается. Проверка числа N на простоту должна делаться с помощью рекурсивного инстанцирования шаблонов, причем асимптотика должна быть O(sqrt(N)).

После этого, используя ранее написанный класс рациональных чисел, написать класс Matrix с тремя шаблонными параметрами: size_t M, size_t N, typename Field=Rational. (По умолчанию берётся поле рациональных чисел, но можно создать матрицу и над конечным полем.)

Матрицы должны поддерживать следующие операции:

Сложение, вычитание, операторы +=, -=. Сложение и вычитание матриц несоответствующих размеров не должно компилироваться.
Умножение на число типа Field.
Умножение двух матриц. Для продвинутого потока – умножение должно работать за o-малое от max(M,N,K)3 (см. напр. алгоритм Штрассена). Попытка перемножить матрицы несоответствующих размеров должна приводить к ошибке компиляции.
Метод det(), возвращающий определитель матрицы за O(N3). Взятие определителя матрицы, у которой M != N, не должно компилироваться. Определитель матрицы над кольцом, которое не является полем, можно не поддерживать.
Метод transposed(), возвращающий транспонированную матрицу.
Метод rank() - вычислить ранг матрицы. Ранг матрицы над кольцом, которое не является полем, можно не поддерживать.
Методы inverted() и invert() - вернуть обратную матрицу и обратить данную матрицу. Попытка обратить матрицу, у которой M != N, должна приводить к ошибке компиляции.
Метод trace() - вычислить след матрицы. Вычисление следа от неквадратной матрицы не должно компилироваться.
Методы getRow(unsigned) и getColumn(unsigned), возвращающие std::array из соответствующих значений.
К матрице должен быть дважды применим оператор [], причём это должно работать как для неконстантных, так и для константных матриц. В первом случае содержимое матрицы должно быть можно таким способом поменять.
Другие способы изменения содержимого матрицы, кроме описанных выше, должны отсутствовать. Однако не запрещается реализовать дополнительные методы для выполнения каких-либо иных алгебраических операций или для удобства работы, если по названию и сигнатуре этих методов будет без комментариев понятно их действие. Квадратные матрицы размера N должно быть можно объявлять всего с одним обязательным шаблонным параметром: SquareMatrix<N>.

